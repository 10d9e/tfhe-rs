//! This module defines CastingKey
//!
//! - [ClientKey] aggregates the keys used to encrypt/decrypt between normal and homomorphic types.

use crate::shortint::engine::ShortintEngine;
use crate::shortint::ClientKey as ShortintClientKey;
use crate::shortint::ServerKey as ShortintServerKey;
use crate::shortint::{CiphertextBase, PBSOrderMarker};

use crate::integer::ciphertext::BaseRadixCiphertext;
use crate::integer::ClientKey as IntegerClientKey;
use crate::integer::RadixClientKey as IntegerRadixClientKey;
use crate::integer::ServerKey as IntegerServerKey;

use crate::high_level_api::ClientKey as HlapiClientKey;
use crate::high_level_api::ServerKey as HlapiServerKey;

use crate::core_crypto::prelude::keyswitch_lwe_ciphertext;
use crate::core_crypto::prelude::LweKeyswitchKeyOwned;

use rayon::prelude::*;
use serde::{Deserialize, Serialize};

mod key_cast;

#[cfg(test)]
mod test_cast;

/// A structure containing the casting public key.
///
/// The casting key is generated by the client and is meant to be published: the client
/// sends it to the server so it can cast from one set of parameters to another.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CastingKey<SrcServerKeyType, DestServerKeyType> {
    pub(crate) key_switching_key: LweKeyswitchKeyOwned<u64>,
    pub(crate) dest_server_key: DestServerKeyType,
    pub(crate) src_server_key: SrcServerKeyType,
    pub cast_rshift: i8,
}

impl<SrcServerKeyType, DestServerKeyType> CastingKey<SrcServerKeyType, DestServerKeyType>
where
    SrcServerKeyType: Clone,
    DestServerKeyType: Clone,
    for<'a> &'a ShortintServerKey: From<&'a DestServerKeyType>,
    for<'a> &'a ShortintServerKey: From<&'a SrcServerKeyType>,
{
    /// Generate a casting key. This can cast to several kinds of keys (shortint, integer, hlapi),
    /// depending on input.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tfhe::shortint::parameters::{PARAM_MESSAGE_1_CARRY_1, PARAM_MESSAGE_2_CARRY_2};
    /// use tfhe::shortint::{gen_keys, CastingKey};
    ///
    /// // Generate the client keys and server keys:
    /// let (ck1, sk1) = gen_keys(PARAM_MESSAGE_1_CARRY_1);
    /// let (ck2, sk2) = gen_keys(PARAM_MESSAGE_2_CARRY_2);
    ///
    /// // Generate the server key:
    /// let ksk = CastingKey::new((&ck1, &sk1), (&ck2, &sk2));
    /// ```
    pub fn new<SrcClientKeyType, DestClientKeyType>(
        key_pair_1: (&SrcClientKeyType, &SrcServerKeyType),
        key_pair_2: (&DestClientKeyType, &DestServerKeyType),
    ) -> Self
    where
        for<'a> &'a ShortintClientKey: From<&'a DestClientKeyType>,
        for<'a> &'a ShortintClientKey: From<&'a SrcClientKeyType>,
    {
        let shortint_ck1: &ShortintClientKey = From::from(key_pair_1.0);
        let shortint_ck2: &ShortintClientKey = From::from(key_pair_2.0);

        // Creation of the key switching key
        let key_switching_key = ShortintEngine::with_thread_local_mut(|engine| {
            engine.new_key_switching_key(shortint_ck1, shortint_ck2)
        });

        let full_message_modulus_1 =
            shortint_ck1.parameters.carry_modulus().0 * shortint_ck1.parameters.message_modulus().0;
        let full_message_modulus_2 =
            shortint_ck2.parameters.carry_modulus().0 * shortint_ck2.parameters.message_modulus().0;
        if (full_message_modulus_1 & (full_message_modulus_1 - 1)) != 0
            || (full_message_modulus_2 & (full_message_modulus_2 - 1)) != 0
        {
            panic!("Cannot create casting key if the full messages moduli are not a power of 2");
        }

        let mut nb_bits_1 = 1i8;
        while full_message_modulus_1 != 1 << nb_bits_1 {
            nb_bits_1 += 1;
        }
        let mut nb_bits_2 = 1i8;
        while full_message_modulus_2 != 1 << nb_bits_2 {
            nb_bits_2 += 1;
        }

        // Pack the keys in the casting key set:
        Self {
            key_switching_key: key_switching_key.unwrap(),
            dest_server_key: key_pair_2.1.clone(),
            src_server_key: key_pair_1.1.clone(),
            cast_rshift: nb_bits_2 - nb_bits_1,
        }
    }

    fn dest_shortint_server_key(&self) -> &ShortintServerKey {
        let ret: &ShortintServerKey = From::from(&self.dest_server_key);
        ret
    }
    fn src_shortint_server_key(&self) -> &ShortintServerKey {
        let ret: &ShortintServerKey = From::from(&self.src_server_key);
        ret
    }

    /// Cast a ciphertext from the source parameter set to the dest parameter set,
    /// using provided &mut.
    ///
    /// # Example (the following code won't actually run because this function is private)
    ///
    /// ```rust
    /// use tfhe::shortint::parameters::{PARAM_MESSAGE_1_CARRY_1, PARAM_MESSAGE_2_CARRY_2};
    /// use tfhe::shortint::{gen_keys, CastingKey};
    ///
    /// // Generate the client keys and server keys:
    /// let (ck1, sk1) = gen_keys(PARAM_MESSAGE_1_CARRY_1);
    /// let (ck2, sk2) = gen_keys(PARAM_MESSAGE_2_CARRY_2);
    ///
    /// // Generate the server key:
    /// let ksk = CastingKey::new((&ck1, &sk1), (&ck2, &sk2));
    ///
    /// let cipher = ck1.encrypt(1);
    /// let cipher_2 = sk2.create_trivial(0);
    /// ksk._cast_assign(&cipher, &mut cipher_2);
    ///
    /// ```
    fn _cast_assign<OpOrder: PBSOrderMarker>(
        &self,
        ct: &CiphertextBase<OpOrder>,
        ct_dest: &mut CiphertextBase<OpOrder>,
    ) {
        match self.cast_rshift {
            // Same bit size: only key switch
            0 => keyswitch_lwe_ciphertext(&self.key_switching_key, &ct.ct, &mut ct_dest.ct),

            // Cast to bigger bit length: keyswitch, then right shift
            i if i > 0 => {
                keyswitch_lwe_ciphertext(&self.key_switching_key, &ct.ct, &mut ct_dest.ct);

                let shortint_server_key = self.dest_shortint_server_key();
                let acc = shortint_server_key.generate_accumulator(|n| n >> i);
                shortint_server_key.apply_lookup_table_assign(ct_dest, &acc);
            }

            // Cast to smaller bit length: left shift, then keyswitch
            i if i < 0 => {
                let shortint_server_key = self.src_shortint_server_key();
                let acc = shortint_server_key.generate_accumulator(|n| n << -i);
                let shifted_cipher = shortint_server_key.apply_lookup_table(&ct, &acc);

                keyswitch_lwe_ciphertext(
                    &self.key_switching_key,
                    &shifted_cipher.ct,
                    &mut ct_dest.ct,
                );
            }

            _ => unreachable!(),
        };
    }

    /// Cast a ciphertext from the source parameter set to the dest parameter set,
    /// returning a new ciphertext.
    ///
    /// # Example (the following code won't actually run because this function is private)
    ///
    /// ```rust
    /// use tfhe::shortint::parameters::{PARAM_MESSAGE_1_CARRY_1, PARAM_MESSAGE_2_CARRY_2};
    /// use tfhe::shortint::{gen_keys, CastingKey};
    ///
    /// // Generate the client keys and server keys:
    /// let (ck1, sk1) = gen_keys(PARAM_MESSAGE_1_CARRY_1);
    /// let (ck2, sk2) = gen_keys(PARAM_MESSAGE_2_CARRY_2);
    ///
    /// // Generate the server key:
    /// let ksk = CastingKey::new((&ck1, &sk1), (&ck2, &sk2));
    ///
    /// let cipher = ck1.encrypt(1);
    /// let cipher_2 = ksk._cast(&cipher);
    ///
    /// ```
    fn _cast<OpOrder: PBSOrderMarker>(
        &self,
        ct: &CiphertextBase<OpOrder>,
    ) -> CiphertextBase<OpOrder> {
        let mut ret = self.dest_shortint_server_key().create_trivial(0);
        self._cast_assign(ct, &mut ret);
        ret
    }
}

impl CastingKey<ShortintServerKey, IntegerServerKey> {
    /// Cast a ciphertext from the source parameter set to the dest parameter set,
    /// returning a new integer radix-packed ciphertext.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tfhe::shortint::parameters::{PARAM_MESSAGE_1_CARRY_1, PARAM_MESSAGE_2_CARRY_2};
    /// use tfhe::shortint::{gen_keys, CastingKey};
    ///
    /// // get low level keys
    /// let (ck1, sk1): (tfhe::shortint::ClientKey, tfhe::shortint::ServerKey) = gen_keys(PARAM_MESSAGE_1_CARRY_1);
    ///
    /// // We generate a set of client/server keys, using the default parameters:
    /// let num_block = 4;
    /// let (client_key, server_key) = tfhe::integer::gen_keys_radix(PARAM_MESSAGE_2_CARRY_2, num_block);
    ///
    /// // Get casting key
    /// let ksk = CastingKey::new((&ck1, &sk1), (&client_key, &server_key));
    ///
    /// // Construct a high level object from blocks
    /// let fhe_int = ksk.cast(
    ///     vec![ck1.encrypt(0), ck1.encrypt(1), ck1.unchecked_encrypt(2), ck1.unchecked_encrypt(3)]
    /// );
    ///
    /// ```
    pub fn cast<OpOrder: PBSOrderMarker>(
        &self,
        blocks: Vec<CiphertextBase<OpOrder>>,
    ) -> BaseRadixCiphertext<CiphertextBase<OpOrder>> {
        BaseRadixCiphertext::<CiphertextBase<OpOrder>>::from(
            blocks
                .par_iter()
                .map(|ct| self._cast(ct))
                .collect::<Vec<_>>(),
        )
    }
}

impl CastingKey<ShortintServerKey, HlapiServerKey> {
    /// Cast a vector of ciphertexts from the source parameter set to the dest parameter set,
    /// returning a high level object.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tfhe::prelude::*;
    /// use tfhe::{ConfigBuilder, generate_keys, FheUint8};
    /// use tfhe::shortint::parameters::{PARAM_MESSAGE_1_CARRY_1};
    /// use tfhe::shortint::{gen_keys, CastingKey};
    ///
    /// // get low level keys
    /// let (ck1, sk1): (tfhe::shortint::ClientKey, tfhe::shortint::ServerKey) = gen_keys(PARAM_MESSAGE_1_CARRY_1);
    ///
    /// // Get high level config and keys
    /// let config = ConfigBuilder::all_disabled().enable_default_integers().build();
    /// let (client_key, server_key) = generate_keys(config);
    ///
    /// // Get casting key
    /// let ksk = CastingKey::new((&ck1, &sk1), (&client_key, &server_key));
    ///
    /// let hl_api_int: FheUint8 = ksk.cast(
    ///     vec![ck1.encrypt(0), ck1.encrypt(1), ck1.unchecked_encrypt(2), ck1.unchecked_encrypt(3)]
    /// );
    ///
    /// ```
    pub fn cast<GenericInteger, OpOrder: PBSOrderMarker>(
        &self,
        blocks: Vec<CiphertextBase<OpOrder>>,
    ) -> GenericInteger
    where
        GenericInteger: From<Vec<CiphertextBase<OpOrder>>>,
    {
        GenericInteger::from(
            blocks
                .par_iter()
                .map(|ct| self._cast(ct))
                .collect::<Vec<_>>(),
        )
    }
}

impl CastingKey<ShortintServerKey, ShortintServerKey> {
    /// Cast a ciphertext from the source parameter set to the dest parameter set,
    /// returning a new ciphertext.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tfhe::shortint::parameters::{PARAM_MESSAGE_1_CARRY_1, PARAM_MESSAGE_2_CARRY_2};
    /// use tfhe::shortint::{gen_keys, CastingKey};
    ///
    /// // Generate the client keys and server keys:
    /// let (ck1, sk1) = gen_keys(PARAM_MESSAGE_1_CARRY_1);
    /// let (ck2, sk2) = gen_keys(PARAM_MESSAGE_2_CARRY_2);
    ///
    /// // Generate the server key:
    /// let ksk = CastingKey::new((&ck1, &sk1), (&ck2, &sk2));
    ///
    /// let cipher = ck1.encrypt(1);
    /// let cipher_2 = ksk.cast(&cipher);
    ///
    /// ```
    pub fn cast<OpOrder: PBSOrderMarker>(
        &self,
        ct: &CiphertextBase<OpOrder>,
    ) -> CiphertextBase<OpOrder> {
        self._cast(ct)
    }
}

impl CastingKey<IntegerServerKey, IntegerServerKey> {
    /// Cast a ciphertext from the source parameter set to the dest parameter set,
    /// returning a new ciphertext.
    ///
    /// # Example
    ///
    /// ```rust
    ///
    /// let num_block = 4;
    ///
    /// // We generate a set of client/server keys, using the default parameters:
    /// let (client_key_1, server_key_1) =
    ///     crate::integer::gen_keys_radix(PARAM_MESSAGE_2_CARRY_2, num_block);
    ///
    /// // We generate a set of client/server keys, using the default parameters:
    /// let (client_key_2, server_key_2) =
    ///     crate::integer::gen_keys_radix(PARAM_MESSAGE_2_CARRY_2, num_block);
    ///
    /// // Get casting key
    /// let ksk = CastingKey::new(
    ///     (&client_key_1, &server_key_1),
    ///     (&client_key_2, &server_key_2),
    /// );
    ///
    /// // Encrypt a value and cast
    /// let ct1 = client_key_1.encrypt(228);
    /// let ct2 = ksk.cast(&ct1);
    ///
    /// ```
    pub fn cast<OpOrder: PBSOrderMarker>(
        &self,
        ct: &BaseRadixCiphertext<CiphertextBase<OpOrder>>,
    ) -> BaseRadixCiphertext<CiphertextBase<OpOrder>> {
        BaseRadixCiphertext::<CiphertextBase<OpOrder>>::from(
            ct.blocks
                .par_iter()
                .map(|ct| self._cast(ct))
                .collect::<Vec<_>>(),
        )
    }
}
